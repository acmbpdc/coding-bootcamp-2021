<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>4: Algorithms - ACMBPDC</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "4: Algorithms";
    var mkdocs_page_input_path = "04-algorithms\\README.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> ACMBPDC</a>
        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Sessions</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../01-command-line-interface/">1: Command Line Interface</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../02-overview-of-programming-languages/">2: Overview of Programming Languages</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../03-data-structures/">3: Data Structures</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">4: Algorithms</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#an-algorithm-is-a-list-of-instructions-given-to-a-computer-to-complete-a-particular-task">An Algorithm is a list of instructions given to a computer to complete a particular task.</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#algorithms-in-computers">Algorithms in Computers</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#essential-algorithms">Essential Algorithms</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#searching-algorithms">Searching Algorithms</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#linear-search">Linear Search</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#binary-search">Binary Search</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#sorting-algorithms">Sorting Algorithms</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#selection-sort">Selection Sort</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#bubble-sort">Bubble Sort</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#insertion-sort">Insertion Sort</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#pathfinding-algorithms">Pathfinding Algorithms</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#breadth-first-search">Breadth First Search</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#depth-first-search">Depth First Search</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#time-complexity">Time Complexity</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#types-of-time-complexity">Types of time complexity</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../05-python-1/">5: Python - 1</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../06-python-2/">6: Python - 2</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../07-git-and-github-1/">7: Git & GitHub - 1</a>
                    </li>
                    <li class="toctree-l1"><a class="" href="https://github.com/acmbpdc/coding-bootcamp-2021/blob/main/Project/ACM_WebScrape_Project.ipynb">8: Git & GitHub - 2</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">ACMBPDC</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>Sessions &raquo;</li>
        
      
    
    <li>4: Algorithms</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="algorithms">Algorithms</h1>
<h2 id="introduction">Introduction</h2>
<p><strong>What is an algorithm?</strong></p>
<blockquote>
<h4 id="an-algorithm-is-a-list-of-instructions-given-to-a-computer-to-complete-a-particular-task"><em>An Algorithm is a list of instructions given to a computer to complete a particular task.</em></h4>
</blockquote>
<p>It is a set of steps that the computer must follow to reach a goal. An example of this would be baking a cake. The recipe would look something like:</p>
<ul>
<li><strong>Step 1:</strong> Gather the ingredients (Flour, Eggs, Sugar, Butter, Milk).</li>
<li><strong>Step 2:</strong> Measure the ingredients to exact quantities.</li>
<li><strong>Step 3:</strong> Mix the ingredients to make the batter.</li>
<li><strong>Step 4:</strong> Put the batter in the oven and bake.</li>
<li><strong>Step 5:</strong> Set a timer</li>
<li><strong>Step 6:</strong> When the timer is done, remove and serve</li>
</ul>
<p><img alt="" src="https://static.toiimg.com/thumb/76401667.cms?width=630&amp;height=420" /></p>
<p>Algorithms are mini-instruction manuals given to computers to solve a problem or manipulate data.</p>
<h2 id="algorithms-in-computers">Algorithms in Computers</h2>
<p>Algorithms in computers are often take an input, executes a series of steps in the order we specify and provide an output. </p>
<p>An example would be a finding the <strong>n-th power of a number</strong>.
Lets say we take an input from the user and calculate and give the output.
First we ask the user for the input for the first number, <em>n</em>, lets say it's 4.
Then we ask for the second input, the power number, <em>p</em>, lets say this is 3.
Next we multiply the first number <em>n</em> (4) by itself the <em>p</em> times (3).
 So,</p>
<pre><code>  4 * 4 * 4 = 64
</code></pre>
<p>We finally submit the following output back to the  user.</p>
<h2 id="essential-algorithms">Essential Algorithms</h2>
<p>The first steps to understanding algorithms comes from learning about two specific types of algorithms.</p>
<ul>
<li>Searching Algorithms</li>
<li>Sorting Algorithms</li>
</ul>
<h2 id="searching-algorithms">Searching Algorithms</h2>
<p><img alt="" src="assets/searching.gif" /></p>
<p>Key Searching algorithms are:</p>
<ul>
<li>Linear Search</li>
<li>Binary Search</li>
</ul>
<h3 id="linear-search">Linear Search</h3>
<p><img alt="" src="assets/linearsearch.gif" /></p>
<p>Linear Search is a simple algorithm used to find an location or index of a number in an array.</p>
<blockquote>
<p>It works by looping over an array, checking each element if it matches the element to be searched. We use a flag variable to track wheter we have found the number. The flag value is set to 0 initially. If the element is found, it breaks the loop and sets the flag to 1. Outside the loop we check if the flag is 0 or 1. If the flag is true, we print the index.</p>
</blockquote>
<p>For this example, we'll be using the following array:
<strong>14 73 36 11 33</strong></p>
<p>The element to be searched: <strong>11</strong></p>
<pre><code>&gt; **14** 74 36 11 33 -- Isn't the number
&gt; 
&gt; 14 **74** 36 11 33 -- Not the number, go to next
&gt; 
&gt; 14 74 **36** 11 33 -- Skip, not the number
&gt;  
&gt; 14 74 36 **11** 33 -- Found the number, break the loop and return
</code></pre>
<p><strong>C Program:</strong></p>
<pre><code>int main()
{
    int nums[] = {14,73,36,11,33};
    int array_size = sizeof(nums)/sizeof(nums[0]);
    int search_key = 11;
    int flag = 0;
    int i; //NOTE that integer i is declared outside the for loop, if it is defined in the for loop, the value cannot be accesed outside the loop in the if statement

    for(i=0;i&lt;array_size;i++) {
        if(nums[i]==search_key) {
            flag = 1;
            break;
        }
    }

    if(flag==1) {
        printf(&quot;Number found at index: %d&quot;, i);
    }
    else {
        printf(&quot;Number not found&quot;);
    }

    return 0;
}
</code></pre>
<h3 id="binary-search">Binary Search</h3>
<p><img alt="" src="assets/binarysearch.gif" /></p>
<p>Binary search looks for a particular item by comparing the middle most item of the collection. If a match occurs, then the index of item is returned. If the middle item is greater than the item, then the item is searched in the sub-array to the left of the middle item. Otherwise, the item is searched for in the sub-array to the right of the middle item. This process continues on the sub-array as well until the size of the subarray reduces to zero</p>
<p>Binary search is done in <strong>4</strong> steps:</p>
<ol>
<li>Compare key with the middle element.</li>
<li>If key matches with the middle element, we return the mid index.</li>
<li>Else If key is greater than the mid element, then key can only lie in the right half subarray after the mid element. So we recur for the right half.</li>
<li>Else (key is smaller) recur for the left half.</li>
</ol>
<blockquote>
<p><strong>NOTE</strong>: Binary Search has a prerequisite that before searching the array must be sorted.</p>
</blockquote>
<p><strong>C Program:</strong></p>
<pre><code>int main()
{
    int nums[] = {11,14,33,36,73}; //We're using an already sorted array 
    int array_size = sizeof(nums)/sizeof(nums[0]);
    int search_key = 14;
    int flag = 0;
    int high = array_size;
    int low = 0;
    int mid = 0; //Mid also variable outside while loop, so can be accessed 

    while(low&lt;=high) {
        mid = (low + high) / 2;
        printf(&quot;%d &quot;,mid);
        if (nums[mid]==search_key) {
            flag = 1;
            break;
        }
        if(nums[mid]&gt;search_key) {
            high = mid - 1;
        }
        else if(nums[mid]&lt;search_key) {
            low = mid + 1;
        }
    }

    if(flag==1) {
        printf(&quot;Number found at index: %d&quot;, mid);
    }
    else {
        printf(&quot;Number not found&quot;);
    }

    return 0;
}
</code></pre>
<h2 id="sorting-algorithms">Sorting Algorithms</h2>
<p><img alt="" src="assets/sorting.gif" /></p>
<blockquote>
<p><em>Sorting is any process of arranging items systematically in sequence ordered by according to some criteria</em></p>
</blockquote>
<p>A sorting algorithm is an important first step in learning to solve more complex problems. It often involves an algorithm that puts elements in a numerical or lexicographical order. </p>
<p>An example would be sorting a list of nums of people in ascending order or descending order. Another example would be sorting a list of names, alphabetically.</p>
<p>This session will focus on three specific algorithms:</p>
<ul>
<li>Selection Sort</li>
<li>Bubble Sort</li>
<li>Insertion Sort</li>
</ul>
<h3 id="selection-sort">Selection Sort</h3>
<p><img alt="" src="assets/selectionsort.gif" /></p>
<p>The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning. The algorithm uses a single array data structure to store the values. </p>
<p>The array gets divided into two halves, the sorted subarray and the unsorted subarray. In the case of sorting number in ascending order, during each iteration, a number from the unsorted half is moved to the sorted half.</p>
<p>The algorithm iterates past each element one by one, for <strong>each iteration it finds the smallest element in the next half and swaps it with the current element</strong>. The following example illustrates this.</p>
<p>We'll be sorting the following list in ascending order:
        <strong>43 28 84 19 64</strong></p>
<pre><code>&gt; arr[] = 43 28 84 19 64
&gt; 
&gt; # Find the minimum element in arr[0...4]  and swap it with the first element
&gt; 
&gt;  ***43** 28 84 19 64* --&gt; **19** 28 84 43 64
&gt; 
&gt; # Go to the next element
&gt; # Find the minimum element in arr[1...4]  and swap it with the first element of arr[1...4] 
&gt; 
&gt;  19 ***28** 84 43 64* --&gt; 19 **28** 84 43 64
&gt; 
&gt; # Go to the next element
&gt; # Find the minimum element in arr[2...4] and swap it with the first element of arr[2...4] 
&gt; 
&gt; 19 28 ***84** 43 64* --&gt; 19 28 **43** 84 64
&gt; 
&gt; # Go to the next element
&gt; # Find the minimum element in arr[3...4] and swap it with the first element of arr[3...4] 
&gt; 
&gt; 19 28 43 ***84** 64* --&gt; 19 28 28 **64** 84
</code></pre>
<p><strong>C Program:</strong></p>
<pre><code>int main()
{
    int nums[] = {43,28,84,19,64};
    int array_size = sizeof(nums)/sizeof(nums[0]);
    int temp,min_ind;

    for(int i=0;i&lt;array_size;i++) {

        min_ind = i;
        for(int j=i+1;j&lt;array_size;j++) {
            if(nums[j]&lt;nums[min_ind]) {
                min_ind = j;
            }

        }
        //Swap the two elements
        temp = nums[i];
        nums[i] = nums[min_ind];
        nums[min_ind] = temp;
    }

    for(int i=0;i&lt;array_size;i++) {
        printf(&quot;%d &quot;, nums[i]);
    }

    return 0;
}
</code></pre>
<h3 id="bubble-sort">Bubble Sort</h3>
<p><img alt="" src="assets/bubblesort.gif" /></p>
<p>Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.</p>
<p>It sorts in multiple passes(or iteration), repeating until it undergoes no swaps. At the <strong>end of each swap the largest element of each pass is gets pushed to the right of the array</strong>. We'll be taking the same array as before and sorting it in ascending order.
<strong>43 28 84 19 64</strong></p>
<pre><code>&gt; arr[] = 43 28 84 19 64
&gt;
&gt; # First Pass:
&gt;
&gt; **43 28** 84 19 64 --&gt; **28 43** 84 19 64    // Each 2 elements are compared and swapped if the first is smaller than the second
&gt;
&gt; 28 **43 84** 19 64 --&gt; 28 **43 84** 19 64
&gt;
&gt; 28 43 **84 19** 64 --&gt; 28 43 **19 84** 64
&gt;
&gt; 28 43 19 **84 64** --&gt; 28 43 19 **64 84**    // 84 Being the biggest element is pushed to the end and fixed
&gt; 
&gt; # Second Pass:
&gt; 
&gt; **28 43** 19 64 84 --&gt; **28 43** 19 64 84 
&gt; 
&gt; 28 **43 19** 64 84 --&gt; 28 **19 43** 64 84
&gt; 
&gt; 28 19 **43 64** 84 --&gt; 28 19 **43 64** 84
&gt; 
&gt; 28 19 43 **64 84** --&gt; 28 19 43 **64 84**    // 64 being the next biggest is pushed to the right most
&gt; 
&gt; Third Pass:
&gt; 
&gt; **28 19** 43 64 84 --&gt; **19 28** 43 64 84
&gt; 
&gt; 19 **28 43** 64 84 --&gt; 19 **28 43** 64 84
&gt; 
&gt; 19 28 **43 64** 84 --&gt; 19 28 **43 64** 84
&gt; 
&gt; 19 28 43 **64 84** --&gt; 19 28 43 **64 84**
</code></pre>
<p><strong>C Program:</strong></p>
<pre><code>int main()
{
    int nums[] = {43,28,84,19,64};
    int array_size = sizeof(nums)/sizeof(nums[0]);
    int temp;

    for(int i=0;i&lt;array_size-1;i++) {
        for(int j=0;j&lt;array_size-i-1;j++) {
            if(nums[j]&gt;nums[j+1]) {
                //Swap the two elements
                temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }

    for(int i=0;i&lt;array_size;i++) {
        printf(&quot;%d &quot;, nums[i]);
    }

    return 0;
}

</code></pre>
<h3 id="insertion-sort">Insertion Sort</h3>
<p><img alt="" src="assets/insertionsort.gif" /></p>
<p>Insertion Sort similar to Selection Sort splits the array into a sorted and unsorted part. Elements in the unsorted part are selected and placed in the correct position in the sorted part.</p>
<p>Once again we use the same array and sort it in ascending order:
<strong>43 28 84 19 64</strong></p>
<pre><code>&gt; arr[] = 43 28 84 19 64
&gt;  
&gt;  **43** 28 84 19 64 --&gt; **28 43** 84 19 64    // 28 being smaller than 48 is placed before it
&gt;  
&gt; **28 43** 84 19 64 --&gt; **28 43 84** 19 64    // 84 being bigger than 43 and being sorted doesn't change its position
&gt;  
&gt; **28 43 84** 19 64 --&gt; **19 28 43 84** 64    // 19 being the smallest element gets pushed to the beginning
&gt;  
&gt; **19 28 43 84** 64 --&gt; **19 28 43 64 84**    // 64 being smaller than 84 but being bigger than other gets pushed to the middle
</code></pre>
<p><strong>C Program:</strong></p>
<pre><code>int main()
{
    int nums[] = {43,28,84,19,64};
    int array_size = sizeof(nums)/sizeof(nums[0]);
    int temp,key;

    for(int i=0;i&lt;array_size-1;i++) {
        key = nums[i];
        int j = i-1;

        while(j&gt;=0 &amp;&amp; nums[j]&gt;key) {
            nums[j+1] = nums[j];
            j = j-1;
        }
        nums[j+1] = key;
    }

    for(int i=0;i&lt;array_size;i++) {
        printf(&quot;%d &quot;, nums[i]);
    }

    return 0;
}
</code></pre>
<h2 id="pathfinding-algorithms">Pathfinding Algorithms</h2>
<h3 id="breadth-first-search">Breadth First Search</h3>
<p>Breadth First Search or BFS is a vertex based technique for finding a shortest path in graph.</p>
<p>It uses a <strong>Queue</strong> data structure which follows first in first out. In BFS, one vertex is selected at a time when it is visited and marked then its adjacent are visited and stored in the queue. It is slower than DFS.</p>
<h3 id="depth-first-search">Depth First Search</h3>
<p>Depth First Search or DFS is a edge based technique. It uses the <strong>Stack</strong> data structure, performs two stages, first visited vertices are pushed into stack and second if there is no vertices then visited vertices are popped.</p>
<p><img alt="" src="https://www.freelancinggig.com/blog/wp-content/uploads/2019/02/BFS-and-DFS-Algorithms.png" /></p>
<h2 id="time-complexity">Time Complexity</h2>
<p>Time complexity is the amount of time taken by an algorithm to run, as a function of the length of the input. It measures the time taken to execute each statement of code in an algorithm.</p>
<p>To elaborate, Time complexity measures the time taken to execute each statement of code in an algorithm. If a statement is set to execute repeatedly then the number of times that statement gets executed is equal to N multiplied by the time required to run that function each time. </p>
<h3 id="types-of-time-complexity">Types of time complexity</h3>
<p>Most widely used notation is the Big-O notation.</p>
<p>The Big-O Time Complexities of the algorithms discussed earlier:</p>
<ul>
<li>Selection Sort: <img alt="formula" src="https://render.githubusercontent.com/render/math?math=O(n^2)" /></li>
<li>Bubble Sort: <img alt="formula" src="https://render.githubusercontent.com/render/math?math=O(n^2)" /></li>
<li>Insertion Sort: <img alt="formula" src="https://render.githubusercontent.com/render/math?math=O(n^2)" /></li>
<li>Linear Search: <img alt="formula" src="https://render.githubusercontent.com/render/math?math=O(n)" /></li>
<li>Binary Search: <img alt="formula" src="https://render.githubusercontent.com/render/math?math=O(log(n))" /></li>
</ul>
<p><img alt="" src="https://miro.medium.com/max/742/1*WBYUz6Lh2Z21DQnEk-MWFQ.png" /></p>
<p><img alt="" src="https://miro.medium.com/max/1400/1*FkQzWqqIMlAHZ_xNrEPKeA.png" /></p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../05-python-1/" class="btn btn-neutral float-right" title="5: Python - 1">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../03-data-structures/" class="btn btn-neutral" title="3: Data Structures"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../03-data-structures/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../05-python-1/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
